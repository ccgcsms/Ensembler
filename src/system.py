"""
Module: System
    This module shall be used to implement subclasses of system1D. It wraps all information needed and generated by a simulation.
"""

import numpy as np
from typing import Iterable, NoReturn
from numbers import Number
import pandas as pd
import scipy.constants as const
pd.options.mode.use_inf_as_na = True
from Ensembler.src import dataStructure as data
from Ensembler.src.potentials.ND import envelopedPotential
from Ensembler.src.potentials._baseclasses import _potentialNDCls as _potentialCls
from Ensembler.src.potentials._baseclasses import _perturbedPotentialNDCls as _perturbedPotentialCls

from Ensembler.src.integrator import _integratorCls
from Ensembler.src.conditions.conditions import Condition

class system:
    '''
    ..autoclass:: Class of a system on a
    potential energy surface defined by a potential1D._potentialCls object or other.
    Different integrators/propagators can be chosen to create an ensemble of states.
    Also other parameters are tunable.
    '''

    #Parameters
    ##essential parts
    potential:_potentialCls = None
    integrator:_integratorCls = None
    conditions:Iterable[Condition]=[]
    
    ##Physical paramerters
    temperature:float = 298.0
    mass:float = 1 #for one particle systems!!!!
    nparticles:int =1 #Todo: adapt it to be multiple particles

    nDim:int=-1
    nStates:int = 1

    #Output
    state = data.basicState
    initial_positions: Iterable[float] or float
    currentState:data.basicState = data.basicState(np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan)
    trajectory:Iterable[data.basicState] = []
        
    #tmpvars - private:
    _currentTotE:(Number) = np.nan
    _currentTotPot:(Number) = np.nan
    _currentTotKin:(Number) = np.nan
    _currentPosition:(Number or Iterable[Number]) = np.nan
    _currentVelocities:(Number or Iterable[Number]) = np.nan
    _currentForce:(Number or Iterable[Number]) = np.nan
    _currentTemperature:(Number or Iterable[Number]) = np.nan

    def __init__(self, potential:_potentialCls, integrator:_integratorCls, conditions:Iterable[Condition]=[],
                 temperature:Number=298.0, position:(Iterable[Number] or Number)=None, mass:Number=1, verbose:bool=True)->NoReturn:

        #BUILD System
        ## Fundamental Parts:
        self.potential = potential
        self.integrator = integrator
        self.conditions = conditions

        ## Physical Paramters
        if(potential.nDim < 1 and isinstance(position, Iterable) and all([isinstance(pos, Number) for pos in position])):  #one  state system.
            self.nDim = len(position)
            self.potential.nDim = self.nDim
        elif(potential.nDim > 0):
            self.nDim = potential.nDim
        else:
            raise IOError("Could not estimate the disered Dimensionality as potential dim was <1 and no initial position was given.")
        self.temperature = temperature
        self.mass = mass

        ###is the potential a state dependent one? - needed for initial pos.
        if(hasattr(potential, "nStates")):
            self.nStates = potential.nStates
            if(hasattr(potential, "states_coupled")):   #does each state get the same position?
                self.states_coupled = potential.states_coupled
            else:
                self.states_coupled = True #Todo: is this a good Idea?
        else:
            self.nstates = 1

        #PREPARE THE SYSTEM
        ##Make System Potential and initial State
        self.potential._set_singlePos_mode()    #easier execution... does apparently not save so much performacne
        self.init_state(initial_position=position)
        self.potential._set_no_type_check()     #initially taken care by system. Saves performance!

        ##check if system should be coupled to conditions:
        for condition in self.conditions:
            if(not hasattr(condition, "system")):
                condition.coupleSystem(self)
            if(not hasattr(condition, "dt") and hasattr(self.integrator, "dt")):
                condition.dt = self.integrator.dt
            else:
                condition.dt=1

        self.verbose = verbose

    """
        Initialisation
    """

    def init_state(self, initial_position=None):
        #initial position given?
        if (type(initial_position) == type(None)):
            self.initial_positions = self.randomPos()
        else:
            self.initial_positions = self.potential._check_positions_type_singlePos(initial_position)

        #self._currentForce = self.potential.dhdpos(self.initial_positions)  #initialise forces!    #todo!

        #set a new current_state
        self.set_current_state(currentPosition=self.initial_positions, currentVelocities=self._currentVelocities, currentForce=self._currentForce, currentTemperature=self.temperature)

    def initVel(self)-> NoReturn:
        if(self.nStates>1):
            self._currentVelocities = [[self._gen_rand_vel() for dim in range(self.nDim)] for s in range(self.nStates)] if(self.nDim>1) else [self._gen_rand_vel() for state in range(self.nStates)]
        else:
            self._currentVelocities = [self._gen_rand_vel() for dim in range(self.nDim)] if (self.nDim > 1) else self._gen_rand_vel()

        self.veltemp = self.mass / const.gas_constant / 1000.0 * np.linalg.norm(self._currentVelocities) ** 2  # t
        return self._currentVelocities

    def _gen_rand_vel(self)->float:
        return np.sqrt(const.gas_constant / 1000.0 * self.temperature / self.mass) * np.random.normal()

    def randomPos(self)-> Iterable:
        if(self.nStates==1 or (self.nStates >1 and self.states_coupled)):
            return self.potential._check_positions_type_singlePos(np.subtract(np.multiply(np.random.rand(self.nDim),20),10))
        else:
            return self.potential._check_positions_type_singlePos([np.subtract(np.multiply(np.random.rand(self.nDim), 20), 10) for state in range(self.nStates)])

    """
        Update
    """
    def totKin(self)-> (Iterable[Number] or Number or None):
        # Todo: more efficient if?
        if(self.nDim == 1 and isinstance(self._currentVelocities, Number) and not np.isnan(self._currentVelocities)):
            return 0.5 * self.mass * np.square(np.linalg.norm(self._currentVelocities))
        elif(self.nDim > 1 and isinstance(self._currentVelocities, Iterable) and all([isinstance(x, Number) and not np.isnan(x) for x in self._currentVelocities])):
            return np.sum(0.5 * self.mass * np.square(np.linalg.norm(self._currentVelocities)))
        else:
            return np.nan

    def totPot(self)-> (Iterable[Number] or Number or None):
        return self.potential.ene(self._currentPosition)

    def updateTemp(self)-> NoReturn:
        """ this looks like a thermostat like thing! not implemented!@ TODO calc velocity from speed"""
        self._currentTemperature = self._currentTemperature

    def updateEne(self)-> NoReturn:
        self._currentTotPot = self.totPot()
        self._currentTotKin = self.totKin()
        self._currentTotE = self._currentTotPot if(np.isnan(self._currentTotKin))else np.add(self._currentTotKin, self._currentTotPot)

    def updateCurrentState(self)-> NoReturn:
        self.currentState = self.state(self._currentPosition, self._currentTemperature,
                                        self._currentTotE, self._currentTotPot, self._currentTotKin,
                                        self._currentForce, self._currentVelocities)

    def _update_current_vars(self):
        self._currentPosition = self.currentState.position
        self._currentTemperature = self.currentState.temperature
        self._currentTotE = self.currentState.totEnergy
        self._currentTotPot = self.currentState.totPotEnergy
        self._currentTotKin = self.state.totKinEnergy
        self._currentForce = self.currentState.dhdpos
        self._currentVelocities = self.currentState.velocity

    """
        Functionality
    """

    def simulate(self, steps:int, initSystem:bool=True, withdrawTraj:bool=False, save_every_state:int=1)-> state:
        if(steps > 1000 and self.verbose):
            show_progress =True
            block_length = steps*0.1
        else:
            show_progress = False

        if(withdrawTraj):
            self.trajectory = []
            
        if(initSystem): #type(self._currentVelocities) == type(None) or type(self._currentPosition) == type(None)
            self.initVel()
            self.init_state(initial_position=self.initial_positions)

        self.updateCurrentState()

        if(show_progress): print("Progress: ", end="\t")
        step = 0
        for step in range(steps):
            if(show_progress and step%block_length==0):
                print(str(100*step//steps)+"%", end="\t")

            if(step%save_every_state == 0 ):
                self.trajectory.append(self.currentState)

            #Do one simulation Step. Todo: change to do multi steps
            self.propagate()

            #Calc new Energy
            self.updateEne()

            #Apply Restraints, Constraints ...
            self.applyConditions()

            #Set new State
            self.updateCurrentState()

        if(step%save_every_state != 0 ):
            self.trajectory.append(self.currentState)

        if(show_progress): print("100%")
        return self.currentState

    def propagate(self)->NoReturn:
        self._currentPosition, self._currentVelocities, self._currentForce = self.integrator.step(self)

    def applyConditions(self)-> NoReturn:
        for aditional in self.conditions:
            aditional.apply()

    def append_state(self, newPosition, newVelocity, newForces)->NoReturn:
        self._currentPosition = newPosition
        self._currentVelocities = newVelocity
        self._currentForce = newForces

        self.updateTemp()
        self.updateEne()
        self.updateCurrentState()

        self.trajectory.append(self.currentState)

    def revertStep(self)-> NoReturn:
        self.currentState = self.trajectory[-2]
        self._update_current_vars()
        return

    """
        Getter
    """

    def getTotPot(self)-> (Iterable[Number] or Number or None):
        return self._currentTotPot

    def getTotEnergy(self)-> (Iterable[Number] or Number or None):
        return self._currentTotE

    def getCurrentState(self)->state:
        return self.currentState
    
    def getTrajectoryObjects(self)->Iterable[state]:
        return self.trajectory

    def getTrajectory(self)->pd.DataFrame:
        return pd.DataFrame.from_dict([frame._asdict() for frame  in self.trajectory])

    def set_position(self, position):
        self._currentPosition = self.potential._check_positions_type_singlePos(position)

    def set_current_state(self, currentPosition:(Number or Iterable), currentVelocities:(Number or Iterable)=0, currentForce:(Number or Iterable)=0, currentTemperature:Number=298):
        self._currentPosition = currentPosition
        self._currentForce = currentForce
        self._currentVelocities = currentVelocities
        self._currentTemperature = currentTemperature
        self.currentState = self.state(self._currentPosition, self._currentTemperature, np.nan, np.nan, np.nan, np.nan, np.nan)

        self.updateEne()
        self.updateCurrentState()

    def set_Temperature(self, temperature):
        """ this looks like a thermostat like thing! not implemented!@"""
        self.temperature = temperature
        self._currentTemperature = temperature
        self.updateEne()

class perturbedSystem(system):
    """
    
    """

    #Lambda Dependend Settings
    state = data.lambdaState
    currentState: data.lambdaState
    potential: _perturbedPotentialCls
    #current lambda
    _currentLam:float = np.nan
    _currentdHdLam:float = np.nan

    def __init__(self, potential:_perturbedPotentialCls, integrator: _integratorCls, conditions: Iterable[Condition]=[],
                 temperature: float = 298.0, position:(Iterable[Number] or float) = None, lam:float=0.0):

        self._currentLam = lam
        if(not isinstance(potential, _perturbedPotentialCls)):
            raise Exception("Potential: "+potential.name+" is not a potential of the _perturbedPotentialCls family! Please use these types for: "+__class__.__name__)
        else:
            if(hasattr(potential, "lam")):
                setattr(potential, "lam", lam)
            else:
                Exception(
                    "Potential: " + potential.name + " has not an attribute lam. But this attribute is needed for representing lambda! Please add the field for: " + __class__.__name__)

        super().__init__(potential=potential, integrator=integrator, conditions=conditions, temperature=temperature, position=position)


    def init_state(self, initial_position=None):
        #initial position given?
        if (type(initial_position) == type(None) or np.isnan(initial_position)):
            self.initial_positions = self.randomPos()
        else:
            self.initial_positions = self.potential._check_positions_type_singlePos(initial_position)

        #self._currentForce = self.potential.dhdpos(self.initial_positions)  #initialise forces!    #todo!

        #set a new current_state
        self.set_current_state(currentPosition=self.initial_positions, currentVelocities=self._currentVelocities, currentForce=self._currentForce, currentTemperature=self.temperature,
                               currentLambda=self._currentLam, currentdHdLam=self._currentdHdLam)

    def initVel(self)-> NoReturn:
        self._currentVelocities = np.array([[self._gen_rand_vel() for dim in range(self.nDim)] for state in range(self.nStates)] if(self.nDim>1) else [self._gen_rand_vel() for state in range(self.nStates)])
        self.veltemp = np.sum(self.mass / const.gas_constant / 1000.0 * np.linalg.norm(self._currentVelocities) ** 2) # t
        return self._currentVelocities

    def set_current_state(self, currentPosition:(Number or Iterable), currentLambda:(Number or Iterable),
                          currentVelocities:(Number or Iterable)=0,  currentdHdLam:(Number or Iterable)=0,
                          currentForce:(Number or Iterable)=0, currentTemperature:Number=298):
        self._currentPosition = currentPosition
        self._currentForce = currentForce
        self._currentVelocities = currentVelocities
        self._currentTemperature = currentTemperature

        self.updateEne()
        self.updateCurrentState()

    def updateCurrentState(self):
        self.currentState = self.state(position=self._currentPosition, temperature=self._currentTemperature,
                                       totEnergy=self._currentTotE,
                                       totPotEnergy=self._currentTotPot, totKinEnergy=self._currentTotKin,
                                       dhdpos=self._currentForce, velocity=self._currentVelocities,
                                       lam=self._currentLam, dhdlam=self._currentdHdLam)

    def append_state(self, newPosition, newVelocity, newForces, newLam):
        self._currentPosition = self.potential._check_positions_type_singlePos(newPosition)
        self._currentVelocities = newVelocity
        self._currentForce = newForces
        self._currentLam = newLam

        self.updateTemp()
        self.updateEne()
        self.updateCurrentState()
        self.trajectory.append(self.currentState)

    def set_lambda(self, lam):
        self._currentLam = lam
        #self.omega = np.sqrt((1.0 + self.potential.alpha * self._currentLam) * self.potential.fc / self.mass)
        self.potential.set_lam(lam=self._currentLam)
        self.updateEne()

    def totKin(self)-> (Iterable[Number] or Number or None):
      # Todo: more efficient if?
      if(self.nDim == 1 and isinstance(self._currentVelocities, Number) and not np.isnan(self._currentVelocities)):
          return 0.5 * self.mass * np.square(np.linalg.norm(self._currentVelocities))
      elif(self.nDim > 1 and isinstance(self._currentVelocities, Iterable) and all([isinstance(x, Number) and not np.isnan(x) for x in self._currentVelocities])):
          return np.sum(0.5 * self.mass * np.square(np.linalg.norm(self._currentVelocities)))
      else:
          return np.nan

    def totPot(self)-> (Iterable[Number] or Number or None):
      return self.potential.ene(self._currentPosition)
